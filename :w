mod created;
use super::{
    content::{Content, ContentMode, ExistingContentID},
    id::ID,
    store::Store,
    ExistingStoryID,
};
use created::*;
use std::fmt::Debug;

/*
░░░░░░░░░░░░░░░░░░░░░░░░░░░ Event
*/

#[derive(Debug)]
pub enum Event {
    Created(Created),
    ContentAdded(ContentAdded),
    ContentPublished(ContentPublished),
    ContentModed(ContentModed),
    ContentDeleted,
    EventDeleted,
}

/// Adds Content to that story
#[derive(Debug)]
pub struct ContentAdded {
    id: ID,
    story_id: ExistingStoryID,
    content: Content,
}

/// Sets a Content as published
#[derive(Debug)]
pub struct ContentPublished {
    id: ID,
    story_id: ExistingStoryID,
    content: ExistingContentID,
}

/// Changes the mode of a content
#[derive(Debug)]
pub struct ContentModed {
    id: ID,
    story_id: ExistingStoryID,
    content: ExistingContentID,
    new_mod: ContentMode,
}

#[derive(Debug)]
pub struct ContentDeleted {
    id: ID,
    story_id: ExistingStoryID,
    content: ExistingContentID,
}

/*
░░░░░░░░░░░░░░░░░░░░░░░░░░░ ID
*/

/// Creates an instance of an event the specified ID
pub struct ExistingEventID {
    id: ID,
    // store is here to confirm that the existing content lives long enough
    _store: Box<dyn Store>,
}

impl Debug for ExistingEventID {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ExistingEventID")
            .field("id", &self.id)
            // .field("store", &self.store.)
            .finish()
    }
}

impl ExistingEventID {
    /// This function is a builder function that creates an instance of validated ID
    /// Which means that the ID exists in the store provided.
    /// The lifetime of the this validated type should at least be as long as the store exists
    ///
    /// * `id`: ID
    /// * `store`: generic over ContentDataBase which lives more than the store
    pub fn build(id: ID, store: Box<dyn Store>) -> Result<Self, IDError> {
        match store.id_exists(&id) {
            true => Ok(Self { id, _store: store }),
            false => Err(IDError::NotFound),
        }
    }
}

#[derive(Debug, thiserror::Error)]
pub enum IDError {
    #[error("Could Not be found")]
    NotFound,
}
